function thetad = inverse_kinematics(u)% performs inverse kinematics computations with various methods% Stefan Schaal, March 2009% split the input u into meaningful quantitiesn = (length(u)-2)/2;theta = u(1:n);xd    = u(n+1:n+2);links = u(n+3:end);n = length(theta);m = length(xd);% NOTE: insert your Jacobian calculation here% Compute Si and Ci in my formulacosines = zeros(n, 1);sines = zeros(n, 1);for i = 2:n    cosines(i,:) = cos(sum(theta(1:i)));    sines(i,:) = sin(sum(theta(1:i)));end% Compute pi p = zeros(3, n);p(:, 1) = [ links(1)*cos(theta(1)), links(1)*sin(theta(1)), 0 ]';for i = 2:n    p(:, i) = p(:,i-1)+[links(i)*cosines(i,:), links(i)*sines(i,:), 0]';end % Compute Jacobians of the jointsjp = zeros(3, n, n);z = [0 0 1]';for i = 1:n   % z0 x (pn-p0) in my formula   jp(:,1,i) = cross(z, p(:,i)-[0 0 0]');   for j = 2:i      jp(:,j,i) = cross(z, p(:,i)-p(:,j-1));   end end   j_mean = sum(jp, 3)/n;J = j_mean(1:2, :);  % convert cartesian velocities into joint velocities% NOTE: insert the required inverse kinematics methods at this%       location% Question 1g% alpha = 1;% thetad = alpha * J' * xd;% Question 1h% alpha = 0.009;% thetad = alpha * J' * inv(J * J') * xd;% Question 1i% alpha = 0.009;% J_sharp = J' * inv( J * J' );% theta_o = 0.1 * ones(n,1);% thetad = alpha * J_sharp * xd + ( eye(n) - J_sharp * J ) * ( theta_o - theta );% Question 1j% alpha = 0.009;% W = diag([1.0 0.5 0.1 0.01]);% thetad = alpha * inv(W) * J' * inv( J * inv(W) * J' ) * xd;% Question 1kalpha = 0.009;W = diag([1.0 0.5 0.1 0.01]);theta_o = 0.1 * ones(n,1);J_w_sharp = inv(W) * J' * inv( J * inv(W) * J' );thetad = alpha * J_w_sharp * xd + ( eye(n) - J_w_sharp * J ) * ( theta_o - theta );